generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions"), vector]
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  feedback        Feedback[]
  inputs          Input[]
  recommendations Recommendation[]
  profile         UserProfile?
}

model UserProfile {
  id              String   @id @default(cuid())
  userId          String   @unique
  location        String?
  farmSize        String?
  cropsOfInterest String[]
  experienceLevel String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Input {
  id              String           @id @default(cuid())
  userId          String
  type            String
  imageUrl        String?
  description     String?
  labData         Json?
  location        String?
  crop            String?
  season          String?
  createdAt       DateTime         @default(now())
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  recommendations Recommendation?
  retrievalAudits RetrievalAudit[]
  testScenarios   TestScenario[]
}

model Recommendation {
  id              String                   @id @default(cuid())
  userId          String
  inputId         String                   @unique
  diagnosis       Json
  confidence      Float
  modelUsed       String
  tokensUsed      Int?
  createdAt       DateTime                 @default(now())
  feedback        Feedback[]
  input           Input                    @relation(fields: [inputId], references: [id], onDelete: Cascade)
  user            User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sources         RecommendationSource[]
  products        ProductRecommendation[]
  evaluations     Evaluation[]
  revisions       RecommendationRevision[]
  retrievalAudits RetrievalAudit[]
}

model Feedback {
  id                  String         @id @default(cuid())
  userId              String
  recommendationId    String         @unique
  helpful             Boolean?
  accuracyRating      Int?
  outcome             String?
  comments            String?
  createdAt           DateTime       @default(now())
  rating              Int?
  accuracy            Int?
  issues              Json?
  detailedCompletedAt DateTime?
  outcomeReported     Boolean        @default(false)
  outcomeApplied      Boolean?
  outcomeSuccess      Boolean?
  outcomeNotes        String?
  outcomeImages       String[]       @default([])
  outcomeTimestamp    DateTime?
  promptVersion       String?
  retrievedChunks     Json?
  suggestedProducts   Json?
  updatedAt           DateTime       @default(now()) @updatedAt
  recommendation      Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Source {
  id             String       @id @default(cuid())
  title          String
  url            String?      @unique
  sourceType     SourceType
  institution    String?
  status         String       @default("pending")
  chunksCount    Int          @default(0)
  errorMessage   String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  metadata       Json?
  // Ingestion scheduling fields (used by API workers, not Prisma ORM)
  priority       String       @default("medium")
  freshnessHours Int          @default(168)
  tags           Json         @default("[]")
  lastScrapedAt  DateTime?
  imageChunks    ImageChunk[]
  textChunks     TextChunk[]
  boost          SourceBoost?
}

model TextChunk {
  id              String                 @id @default(cuid())
  sourceId        String
  content         String
  embedding       Unsupported("vector")?
  metadata        Json?
  createdAt       DateTime               @default(now())
  chunkIndex      Int                    @default(0)
  contentHash     String?                @unique
  recommendations RecommendationSource[]
  source          Source                 @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
}

model ImageChunk {
  id                    String                 @id @default(cuid())
  sourceId              String
  imageUrl              String
  caption               String?
  embedding             Unsupported("vector")?
  metadata              Json?
  createdAt             DateTime               @default(now())
  contentHash           String?                @unique
  altText               String?
  contextText           String?
  contextChunkId        String?
  source                Source                 @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  recommendationSources RecommendationSource[]

  @@unique([sourceId, imageUrl])
  @@index([sourceId])
}

model RecommendationSource {
  id               String         @id @default(cuid())
  recommendationId String
  textChunkId      String?
  imageChunkId     String?
  relevanceScore   Float?
  imageChunk       ImageChunk?    @relation(fields: [imageChunkId], references: [id])
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  textChunk        TextChunk?     @relation(fields: [textChunkId], references: [id])
}

model Product {
  id              String                  @id @default(cuid())
  name            String
  brand           String?
  type            ProductType
  analysis        Json?
  applicationRate String?
  crops           String[]
  description     String?                 @db.Text
  metadata        Json?
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
  recommendations ProductRecommendation[]
  pricingCache    ProductPricingCache[]

  @@index([type])
  @@index([name])
}

model ProductRecommendation {
  id               String         @id @default(cuid())
  recommendationId String
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  productId        String
  product          Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  reason           String         @db.Text
  applicationRate  String?
  priority         Int            @default(1)
  searchQuery      String?
  searchTimestamp  DateTime       @default(now())
  createdAt        DateTime       @default(now())

  @@unique([recommendationId, productId])
  @@index([recommendationId])
  @@index([productId])
}

model ProductPricingCache {
  id        String   @id @default(cuid())
  productId String
  region    String
  pricing   Json
  cachedAt  DateTime @default(now())
  expiresAt DateTime
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, region])
  @@index([productId])
  @@index([expiresAt])
}

model TestScenario {
  id                    String       @id @default(cuid())
  inputId               String?
  scenarioType          String
  expectedDiagnosis     String
  expectedConditionType String
  mustInclude           String[]
  shouldAvoid           String[]
  symptoms              String
  crop                  String
  location              String
  season                String?
  sourceFocus           String[]     @default([])
  createdAt             DateTime     @default(now())
  input                 Input?       @relation(fields: [inputId], references: [id])
  evaluations           Evaluation[]
}

model RetrievalAudit {
  id                String          @id @default(cuid())
  inputId           String
  recommendationId  String?
  query             String          @db.Text
  topics            String[]
  sourceHints       String[]
  requiredSourceIds String[]
  candidateChunks   Json
  usedChunks        Json
  missedChunks      Json
  createdAt         DateTime        @default(now())
  input             Input           @relation(fields: [inputId], references: [id])
  recommendation    Recommendation? @relation(fields: [recommendationId], references: [id])
}

model Evaluation {
  id                 String         @id @default(cuid())
  recommendationId   String
  scenarioId         String?
  overall            Int
  accuracy           Int
  helpfulness        Int
  faithfulness       Int
  actionability      Int
  completeness       Int
  retrievalRelevance Int
  issues             Json?
  missingEvidence    Json?
  llmJudgeOutput     Json?
  createdAt          DateTime       @default(now())
  recommendation     Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  scenario           TestScenario?  @relation(fields: [scenarioId], references: [id])
}

model RecommendationRevision {
  id               String         @id @default(cuid())
  recommendationId String
  revisionIndex    Int
  promptVersion    String
  diagnosis        Json
  confidence       Float
  forcedSourceIds  String[]
  createdAt        DateTime       @default(now())
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
}

model SourceBoost {
  id            String   @id @default(cuid())
  sourceId      String   @unique
  boost         Float    @default(0)
  feedbackCount Int      @default(0)
  updatedAt     DateTime @default(now()) @updatedAt
  source        Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
}

enum ProductType {
  FERTILIZER
  AMENDMENT
  PESTICIDE
  HERBICIDE
  FUNGICIDE
  INSECTICIDE
  SEED_TREATMENT
  BIOLOGICAL
  OTHER
}

enum SourceType {
  UNIVERSITY_EXTENSION
  MANUFACTURER
  RETAILER
  RESEARCH_PAPER
  GOVERNMENT
}
